# Modelado Logico de Datos

**Tiempo estimado**: 30 minutos
**Nivel**: Intermedio
**Prerrequisitos**: Modelado Conceptual de Datos (4.1.1)

---

## Por que importa este subtema?

El modelo logico transforma el modelo conceptual en una estructura que puede implementarse en una base de datos. Mientras el modelo conceptual es para comunicar con negocio, el modelo logico es el puente hacia la implementacion tecnica.

---

## De Conceptual a Logico

| Aspecto | Conceptual | Logico |
|---------|------------|--------|
| Audiencia | Negocio | Tecnicos |
| Entidades | Conceptos de negocio | Tablas |
| Atributos | Caracteristicas | Columnas con tipos |
| Relaciones | Asociaciones | Foreign keys |
| Cardinalidad | 1:N, M:N | Tablas intermedias |
| Normalizacion | No aplica | 3FN tipicamente |

---

## Proceso de Conversion

### Paso 1: Convertir entidades a tablas

Cada entidad conceptual se convierte en una tabla:

```
CONCEPTUAL                    LOGICO
+------------------+          +------------------+
|     CLIENTE      |   -->    |     cliente      |
+------------------+          +------------------+
| * cliente_id     |          | cliente_id  PK   |
| o nombre         |          | nombre VARCHAR   |
| o email          |          | email VARCHAR UK |
| o segmento       |          | segmento_id FK   |
+------------------+          | created_at TS    |
                              | updated_at TS    |
                              +------------------+
```

### Paso 2: Definir tipos de datos

| Atributo conceptual | Tipo logico | Restricciones |
|---------------------|-------------|---------------|
| cliente_id | INTEGER | PRIMARY KEY, AUTO_INCREMENT |
| nombre | VARCHAR(100) | NOT NULL |
| email | VARCHAR(255) | NOT NULL, UNIQUE |
| fecha_registro | TIMESTAMP | NOT NULL, DEFAULT NOW() |
| monto | DECIMAL(12,2) | NOT NULL, CHECK >= 0 |
| estado | ENUM('activo','inactivo') | NOT NULL |

### Paso 3: Resolver relaciones

**1:N (Uno a Muchos)**
```
CLIENTE 1 ------- N PEDIDO

Se resuelve con FK en el lado "muchos":

pedido
+------------------+
| pedido_id    PK  |
| cliente_id   FK  |  --> referencia a cliente.cliente_id
| fecha            |
| total            |
+------------------+
```

**M:N (Muchos a Muchos)**
```
PRODUCTO N ------- N PROVEEDOR

Se resuelve con tabla intermedia:

producto_proveedor
+---------------------+
| producto_id     FK  |  --> referencia a producto
| proveedor_id    FK  |  --> referencia a proveedor
| precio_compra       |
| lead_time_dias      |
| PRIMARY KEY (producto_id, proveedor_id)
+---------------------+
```

### Paso 4: Normalizar

**1FN**: Eliminar grupos repetitivos
**2FN**: Eliminar dependencias parciales
**3FN**: Eliminar dependencias transitivas

---

## Ejemplo Completo: E-commerce

### Modelo Logico

```sql
-- Dominios base
CREATE TABLE segmento (
    segmento_id     SERIAL PRIMARY KEY,
    nombre          VARCHAR(50) NOT NULL,
    descripcion     TEXT
);

CREATE TABLE categoria (
    categoria_id    SERIAL PRIMARY KEY,
    nombre          VARCHAR(100) NOT NULL,
    categoria_padre_id INTEGER REFERENCES categoria(categoria_id),
    nivel           SMALLINT NOT NULL DEFAULT 1
);

-- Entidades principales
CREATE TABLE cliente (
    cliente_id      SERIAL PRIMARY KEY,
    codigo          VARCHAR(20) NOT NULL UNIQUE,
    nombre          VARCHAR(100) NOT NULL,
    email           VARCHAR(255) NOT NULL UNIQUE,
    tipo            VARCHAR(10) NOT NULL CHECK (tipo IN ('B2B', 'B2C')),
    segmento_id     INTEGER REFERENCES segmento(segmento_id),
    fecha_registro  TIMESTAMP NOT NULL DEFAULT NOW(),
    activo          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at      TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE producto (
    producto_id     SERIAL PRIMARY KEY,
    sku             VARCHAR(50) NOT NULL UNIQUE,
    nombre          VARCHAR(200) NOT NULL,
    descripcion     TEXT,
    categoria_id    INTEGER NOT NULL REFERENCES categoria(categoria_id),
    precio_base     DECIMAL(12,2) NOT NULL CHECK (precio_base >= 0),
    costo           DECIMAL(12,2) CHECK (costo >= 0),
    stock_actual    INTEGER NOT NULL DEFAULT 0,
    stock_minimo    INTEGER NOT NULL DEFAULT 0,
    activo          BOOLEAN NOT NULL DEFAULT TRUE,
    created_at      TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE pedido (
    pedido_id       SERIAL PRIMARY KEY,
    numero          VARCHAR(20) NOT NULL UNIQUE,
    cliente_id      INTEGER NOT NULL REFERENCES cliente(cliente_id),
    fecha           TIMESTAMP NOT NULL DEFAULT NOW(),
    estado          VARCHAR(20) NOT NULL DEFAULT 'pendiente'
                    CHECK (estado IN ('pendiente','confirmado','enviado',
                                     'entregado','cancelado')),
    canal           VARCHAR(20) NOT NULL CHECK (canal IN ('web','app','telefono')),
    subtotal        DECIMAL(12,2) NOT NULL,
    impuestos       DECIMAL(12,2) NOT NULL,
    total           DECIMAL(12,2) NOT NULL,
    notas           TEXT,
    created_at      TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE linea_pedido (
    linea_id        SERIAL PRIMARY KEY,
    pedido_id       INTEGER NOT NULL REFERENCES pedido(pedido_id),
    producto_id     INTEGER NOT NULL REFERENCES producto(producto_id),
    cantidad        INTEGER NOT NULL CHECK (cantidad > 0),
    precio_unitario DECIMAL(12,2) NOT NULL,
    descuento_pct   DECIMAL(5,2) NOT NULL DEFAULT 0,
    subtotal        DECIMAL(12,2) NOT NULL,
    UNIQUE (pedido_id, producto_id)
);

CREATE TABLE factura (
    factura_id      SERIAL PRIMARY KEY,
    numero          VARCHAR(20) NOT NULL UNIQUE,
    pedido_id       INTEGER NOT NULL REFERENCES pedido(pedido_id),
    fecha_emision   DATE NOT NULL,
    fecha_vencimiento DATE NOT NULL,
    total           DECIMAL(12,2) NOT NULL,
    estado          VARCHAR(20) NOT NULL DEFAULT 'pendiente'
                    CHECK (estado IN ('pendiente','pagada','vencida','cancelada')),
    created_at      TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE pago (
    pago_id         SERIAL PRIMARY KEY,
    factura_id      INTEGER NOT NULL REFERENCES factura(factura_id),
    fecha           TIMESTAMP NOT NULL DEFAULT NOW(),
    monto           DECIMAL(12,2) NOT NULL CHECK (monto > 0),
    metodo          VARCHAR(20) NOT NULL
                    CHECK (metodo IN ('tarjeta','transferencia','efectivo')),
    referencia      VARCHAR(100),
    estado          VARCHAR(20) NOT NULL DEFAULT 'procesando'
                    CHECK (estado IN ('procesando','aprobado','rechazado'))
);

-- Indices para rendimiento
CREATE INDEX idx_cliente_email ON cliente(email);
CREATE INDEX idx_cliente_segmento ON cliente(segmento_id);
CREATE INDEX idx_producto_categoria ON producto(categoria_id);
CREATE INDEX idx_producto_sku ON producto(sku);
CREATE INDEX idx_pedido_cliente ON pedido(cliente_id);
CREATE INDEX idx_pedido_fecha ON pedido(fecha);
CREATE INDEX idx_pedido_estado ON pedido(estado);
CREATE INDEX idx_linea_pedido ON linea_pedido(pedido_id);
CREATE INDEX idx_factura_pedido ON factura(pedido_id);
CREATE INDEX idx_pago_factura ON pago(factura_id);
```

---

## Diagrama Logico (ERD)

```
+------------------+       +------------------+
|    segmento      |       |    categoria     |
+------------------+       +------------------+
| PK segmento_id   |       | PK categoria_id  |
|    nombre        |       |    nombre        |
|    descripcion   |       | FK categoria_padre_id
+--------+---------+       +--------+---------+
         | 1                        | 1
         |                          |
         | N                        | N
+--------+---------+       +--------+---------+
|     cliente      |       |    producto      |
+------------------+       +------------------+
| PK cliente_id    |       | PK producto_id   |
|    codigo UK     |       |    sku UK        |
|    nombre        |       |    nombre        |
|    email UK      |       | FK categoria_id  |
|    tipo          |       |    precio_base   |
| FK segmento_id   |       |    stock_actual  |
+--------+---------+       +--------+---------+
         | 1                        | 1
         |                          |
         | N                        | N
+--------+---------+       +--------+---------+
|     pedido       |       |  linea_pedido    |
+------------------+ 1   N +------------------+
| PK pedido_id     |-------| PK linea_id      |
|    numero UK     |       | FK pedido_id     |
| FK cliente_id    |       | FK producto_id   |
|    fecha         |       |    cantidad      |
|    estado        |       |    precio_unit   |
|    total         |       +------------------+
+--------+---------+
         | 1
         |
         | N
+--------+---------+
|     factura      |
+------------------+
| PK factura_id    |
|    numero UK     |
| FK pedido_id     |
|    fecha_emision |
|    estado        |
+--------+---------+
         | 1
         |
         | N
+--------+---------+
|      pago        |
+------------------+
| PK pago_id       |
| FK factura_id    |
|    monto         |
|    metodo        |
|    estado        |
+------------------+
```

---

## Consideraciones de Diseno

### Claves naturales vs surrogadas

| Tipo | Ejemplo | Ventaja | Desventaja |
|------|---------|---------|------------|
| Natural | email, RFC | Significado de negocio | Puede cambiar |
| Surrogada | cliente_id (serial) | Inmutable, eficiente | Sin significado |

**Recomendacion**: Usar surrogadas como PK, naturales como UK.

### Soft delete vs hard delete

```sql
-- Soft delete (recomendado para auditoria)
ALTER TABLE cliente ADD COLUMN deleted_at TIMESTAMP NULL;

-- Query normal excluye eliminados
SELECT * FROM cliente WHERE deleted_at IS NULL;
```

### Campos de auditoria

Incluir en todas las tablas:
- `created_at` - cuando se creo
- `updated_at` - ultima modificacion
- `created_by` - quien creo (opcional)
- `updated_by` - quien modifico (opcional)

---

## Resumen

| Concepto | Descripcion |
|----------|-------------|
| Modelo logico | Estructura de datos implementable |
| Tabla | Entidad convertida |
| PK | Identificador unico (primary key) |
| FK | Referencia a otra tabla (foreign key) |
| Normalizacion | Eliminar redundancia (3FN) |
| Indices | Optimizacion de consultas |

**Siguiente subtema**: Gobierno de Datos (4.1.3)
